---
created: 2025-11-29
updated: 2025-11-29
version: 0.2.0
status: ready
parent: '[[v0.2-spec]]'
---

# Rackarr v0.2 — Implementation Prompt Plan

**Spec:** [[v0.2-spec|v0.2 Multi-View & Polish Specification]]

This document provides sequenced implementation prompts for v0.2 features.

---

## Overview

### Version Goal

Add rear rack view capability, improve canvas usability with fit-all zoom, enable rack duplication, enhance device library management, and apply UI polish.

### Approach

1. **Phase 1: Technical Foundation** — Coordinate system refactor and panzoom integration (unblocks all canvas features)
2. **Phase 2: Core Features** — Rear view, fit all, rack duplication
3. **Phase 3: UI Polish** — Toolbar, drawer, and rendering fixes
4. **Phase 4: Data & Migration** — Device library import, version handling

### Dependency Graph

```
Phase 1 (Foundation)
├── P01: screenToSVG utility (getScreenCTM)
└── P02: panzoom integration
    └── P03: Fit All zoom (depends on P02)

Phase 2 (Core Features)
├── P04: Rear view data model (independent)
├── P05: Rear view toggle UI (depends on P04)
├── P06: Device face assignment (depends on P04)
└── P07: Rack duplication (independent)

Phase 3 (UI Polish)
├── P08: Device Library toggle button (independent)
├── P09: Device Library drawer changes (depends on P08)
├── P10: Rack title above rack (independent)
├── P11: Device icon alignment (independent)
└── P12: Help panel update (independent)

Phase 4 (Data & Migration)
├── P13: Device Library import (independent)
└── P14: v0.1 → v0.2 migration (depends on P04)
```

---

## Phase 1: Technical Foundation

### P01: Coordinate System Refactor (getScreenCTM)

**Status:** ✅ Complete

**Goal:** Replace manual zoom compensation with transform-aware coordinate utilities.

**Context:**

- Current code uses `getBoundingClientRect()` + manual `/ zoomScale` division
- This breaks when pan transforms are added
- `getScreenCTM().inverse()` automatically handles all transforms

**Files to modify:**

- `src/lib/utils/coordinates.ts` (new file)
- `src/lib/utils/dragdrop.ts` (update to use new utilities)
- `src/lib/components/Rack.svelte` (update drag handlers)

**Spec reference:** v0.2 Section 4.2

**Tests first:**

```typescript
// src/lib/utils/coordinates.test.ts
import { describe, it, expect, vi } from 'vitest';
import { screenToSVG, svgToScreen } from './coordinates';

describe('screenToSVG', () => {
	it('converts screen coordinates to SVG user space', () => {
		// Create mock SVG element with known CTM
		const mockSvg = createMockSVG({ a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 });
		const result = screenToSVG(mockSvg, 100, 200);
		expect(result).toEqual({ x: 100, y: 200 });
	});

	it('accounts for zoom transform', () => {
		// CTM with 2x zoom
		const mockSvg = createMockSVG({ a: 2, b: 0, c: 0, d: 2, e: 0, f: 0 });
		const result = screenToSVG(mockSvg, 200, 400);
		expect(result).toEqual({ x: 100, y: 200 });
	});

	it('accounts for pan transform', () => {
		// CTM with 50px pan
		const mockSvg = createMockSVG({ a: 1, b: 0, c: 0, d: 1, e: 50, f: 50 });
		const result = screenToSVG(mockSvg, 150, 150);
		expect(result).toEqual({ x: 100, y: 100 });
	});

	it('accounts for combined zoom and pan', () => {
		// 2x zoom + 100px pan
		const mockSvg = createMockSVG({ a: 2, b: 0, c: 0, d: 2, e: 100, f: 100 });
		const result = screenToSVG(mockSvg, 300, 300);
		expect(result).toEqual({ x: 100, y: 100 });
	});
});

describe('svgToScreen', () => {
	it('converts SVG coordinates to screen space', () => {
		const mockSvg = createMockSVG({ a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 });
		const result = svgToScreen(mockSvg, 100, 200);
		expect(result).toEqual({ clientX: 100, clientY: 200 });
	});

	it('accounts for zoom transform', () => {
		const mockSvg = createMockSVG({ a: 2, b: 0, c: 0, d: 2, e: 0, f: 0 });
		const result = svgToScreen(mockSvg, 100, 200);
		expect(result).toEqual({ clientX: 200, clientY: 400 });
	});
});

function createMockSVG(matrix: {
	a: number;
	b: number;
	c: number;
	d: number;
	e: number;
	f: number;
}) {
	// Helper to create mock SVG with specified CTM
	// Implementation details for test setup
}
```

**Implementation:**

```typescript
// src/lib/utils/coordinates.ts

/**
 * Convert screen coordinates to SVG user space coordinates.
 * Accounts for all transforms (zoom, pan, CSS) automatically.
 */
export function screenToSVG(
	svg: SVGSVGElement,
	clientX: number,
	clientY: number
): { x: number; y: number } {
	const pt = svg.createSVGPoint();
	pt.x = clientX;
	pt.y = clientY;
	const ctm = svg.getScreenCTM();
	if (!ctm) return { x: clientX, y: clientY };
	const transformed = pt.matrixTransform(ctm.inverse());
	return { x: transformed.x, y: transformed.y };
}

/**
 * Convert SVG user space coordinates to screen coordinates.
 */
export function svgToScreen(
	svg: SVGSVGElement,
	x: number,
	y: number
): { clientX: number; clientY: number } {
	const pt = svg.createSVGPoint();
	pt.x = x;
	pt.y = y;
	const ctm = svg.getScreenCTM();
	if (!ctm) return { clientX: x, clientY: y };
	const transformed = pt.matrixTransform(ctm);
	return { clientX: transformed.x, clientY: transformed.y };
}
```

**Migration steps:**

1. Create `coordinates.ts` with new utilities
2. Find all uses of manual zoom compensation in drag handlers
3. Replace with `screenToSVG()` calls
4. Remove `zoomScale` parameter from affected functions
5. Run existing drag-drop tests to verify behaviour preserved

**Commit:** `feat(canvas): add transform-aware coordinate utilities`

---

### P02: panzoom Integration

**Goal:** Replace manual zoom/pan with panzoom library for smooth canvas navigation.

**Context:**

- Current zoom uses CSS transform on `.rack-container`
- panzoom provides momentum, bounds, and smooth animations
- Canvas structure changes: SVG wraps all content in panzoom-controlled `<g>`

**Dependencies:** P01 (coordinate utilities must use getScreenCTM)

**Files to modify:**

- `package.json` (add panzoom dependency)
- `src/lib/components/Canvas.svelte` (integrate panzoom)
- `src/lib/stores/canvas.svelte.ts` (expose panzoom instance for external control)

**Spec reference:** v0.2 Section 4.1

**Install dependency:**

```bash
npm install panzoom@^9.4.3
```

**Tests first:**

```typescript
// src/lib/components/Canvas.test.ts
import { describe, it, expect, vi } from 'vitest';
import { render, fireEvent } from '@testing-library/svelte';
import Canvas from './Canvas.svelte';

describe('Canvas panzoom integration', () => {
	it('initializes panzoom on mount', async () => {
		const { container } = render(Canvas);
		const svg = container.querySelector('svg');
		const panzoomGroup = svg?.querySelector('g[data-panzoom]');
		expect(panzoomGroup).toBeTruthy();
	});

	it('zoom buttons control panzoom instance', async () => {
		const { getByLabelText } = render(Canvas);
		const zoomIn = getByLabelText('Zoom in');
		await fireEvent.click(zoomIn);
		// Verify zoom level changed
	});

	it('disposes panzoom on unmount', async () => {
		const { unmount } = render(Canvas);
		// Verify no memory leaks
		unmount();
	});

	it('respects minZoom and maxZoom bounds', async () => {
		// Test that zoom doesn't exceed 0.25 - 2.0 range
	});
});
```

**Implementation:**

```svelte
<!-- src/lib/components/Canvas.svelte -->
<script lang="ts">
	import panzoom from 'panzoom';
	import { onMount } from 'svelte';
	import { canvasStore } from '$lib/stores/canvas.svelte';

	let svgElement: SVGSVGElement;
	let panzoomGroup: SVGGElement;
	let panzoomInstance: ReturnType<typeof panzoom>;

	onMount(() => {
		panzoomInstance = panzoom(panzoomGroup, {
			bounds: true,
			maxZoom: 2,
			minZoom: 0.25,
			smoothScroll: false, // We control zoom via buttons
			zoomDoubleClickSpeed: 1 // Disable double-click zoom
		});

		// Expose instance for external control (Fit All, etc.)
		canvasStore.setPanzoomInstance(panzoomInstance);

		return () => {
			panzoomInstance.dispose();
		};
	});

	function handleZoomIn() {
		const transform = panzoomInstance.getTransform();
		panzoomInstance.zoomAbs(transform.x, transform.y, transform.scale * 1.25);
	}

	function handleZoomOut() {
		const transform = panzoomInstance.getTransform();
		panzoomInstance.zoomAbs(transform.x, transform.y, transform.scale / 1.25);
	}
</script>

<svg bind:this={svgElement} class="canvas">
	<g bind:this={panzoomGroup} data-panzoom>
		{#each racks as rack (rack.id)}
			<Rack {rack} />
		{/each}
	</g>
</svg>
```

**Canvas store extension:**

```typescript
// src/lib/stores/canvas.svelte.ts (additions)
import type panzoom from 'panzoom';

let panzoomInstance = $state<ReturnType<typeof panzoom> | null>(null);

export const canvasStore = {
	// ... existing exports

	setPanzoomInstance(instance: ReturnType<typeof panzoom>) {
		panzoomInstance = instance;
	},

	getPanzoomInstance() {
		return panzoomInstance;
	},

	getTransform() {
		return panzoomInstance?.getTransform() ?? { x: 0, y: 0, scale: 1 };
	}
};
```

**Migration steps:**

1. Install panzoom package
2. Update Canvas.svelte structure (wrap racks in `<g>`)
3. Initialize panzoom on mount
4. Update zoom button handlers to use panzoom API
5. Remove old CSS transform zoom implementation
6. Update canvas store with panzoom instance access
7. Verify drag-drop still works (uses P01 coordinate utilities)

**Commit:** `feat(canvas): integrate panzoom for zoom and pan`

---

### P03: Fit All Zoom

**Goal:** Add button to zoom/pan canvas to fit all racks in viewport.

**Dependencies:** P02 (requires panzoom instance)

**Files to modify:**

- `src/lib/components/Toolbar.svelte` (add Fit All button)
- `src/lib/stores/canvas.svelte.ts` (add fitAll function)
- `src/lib/utils/canvas.ts` (add bounding box calculation)

**Spec reference:** v0.2 Section 3.2

**Tests first:**

```typescript
// src/lib/utils/canvas.test.ts
import { describe, it, expect } from 'vitest';
import { calculateFitAll, calculateRacksBoundingBox } from './canvas';

describe('calculateRacksBoundingBox', () => {
	it('returns empty bounds for no racks', () => {
		const bounds = calculateRacksBoundingBox([]);
		expect(bounds).toEqual({ x: 0, y: 0, width: 0, height: 0 });
	});

	it('calculates bounds for single rack', () => {
		const racks = [{ x: 100, y: 50, width: 200, height: 800 }];
		const bounds = calculateRacksBoundingBox(racks);
		expect(bounds).toEqual({ x: 100, y: 50, width: 200, height: 800 });
	});

	it('calculates bounds for multiple racks', () => {
		const racks = [
			{ x: 0, y: 0, width: 100, height: 100 },
			{ x: 200, y: 50, width: 100, height: 150 }
		];
		const bounds = calculateRacksBoundingBox(racks);
		expect(bounds).toEqual({ x: 0, y: 0, width: 300, height: 200 });
	});
});

describe('calculateFitAll', () => {
	it('returns default for no racks', () => {
		const result = calculateFitAll([], 800, 600);
		expect(result).toEqual({ zoom: 1, panX: 0, panY: 0 });
	});

	it('calculates zoom to fit single rack with padding', () => {
		const racks = [{ x: 0, y: 0, width: 200, height: 400 }];
		const result = calculateFitAll(racks, 800, 600);
		// Should fit with 48px padding on each side
		expect(result.zoom).toBeGreaterThan(0);
		expect(result.zoom).toBeLessThanOrEqual(2); // Max zoom cap
	});

	it('caps zoom at 200%', () => {
		const racks = [{ x: 0, y: 0, width: 50, height: 50 }];
		const result = calculateFitAll(racks, 800, 600);
		expect(result.zoom).toBe(2);
	});

	it('centres content in viewport', () => {
		const racks = [{ x: 0, y: 0, width: 400, height: 300 }];
		const result = calculateFitAll(racks, 800, 600);
		// Content should be centred
		expect(result.panX).toBeGreaterThan(0);
		expect(result.panY).toBeGreaterThan(0);
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/canvas.ts

interface Bounds {
	x: number;
	y: number;
	width: number;
	height: number;
}

interface RackPosition {
	x: number;
	y: number;
	width: number;
	height: number;
}

export function calculateRacksBoundingBox(racks: RackPosition[]): Bounds {
	if (racks.length === 0) {
		return { x: 0, y: 0, width: 0, height: 0 };
	}

	let minX = Infinity;
	let minY = Infinity;
	let maxX = -Infinity;
	let maxY = -Infinity;

	for (const rack of racks) {
		minX = Math.min(minX, rack.x);
		minY = Math.min(minY, rack.y);
		maxX = Math.max(maxX, rack.x + rack.width);
		maxY = Math.max(maxY, rack.y + rack.height);
	}

	return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY - minY
	};
}

export function calculateFitAll(
	racks: RackPosition[],
	viewportWidth: number,
	viewportHeight: number
): { zoom: number; panX: number; panY: number } {
	if (racks.length === 0) {
		return { zoom: 1, panX: 0, panY: 0 };
	}

	const bounds = calculateRacksBoundingBox(racks);
	const padding = 48;
	const contentWidth = bounds.width + padding * 2;
	const contentHeight = bounds.height + padding * 2;

	const zoomX = viewportWidth / contentWidth;
	const zoomY = viewportHeight / contentHeight;
	const zoom = Math.min(zoomX, zoomY, 2); // Cap at 200%

	const panX = (viewportWidth - bounds.width * zoom) / 2 - bounds.x * zoom;
	const panY = (viewportHeight - bounds.height * zoom) / 2 - bounds.y * zoom;

	return { zoom, panX, panY };
}
```

**Toolbar addition:**

```svelte
<!-- In Toolbar.svelte -->
<button
	class="toolbar-button"
	onclick={handleFitAll}
	aria-label="Fit all racks in view"
	title="Fit All (F)"
>
	<FitAllIcon />
</button>
```

**Animation with reduced motion respect:**

```typescript
function fitAll() {
	const { zoom, panX, panY } = calculateFitAll(racks, viewportWidth, viewportHeight);
	const instance = canvasStore.getPanzoomInstance();
	if (!instance) return;

	const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

	if (prefersReducedMotion) {
		instance.zoomAbs(0, 0, zoom);
		instance.moveTo(panX, panY);
	} else {
		// Animate over 200ms
		instance.smoothZoomAbs(panX, panY, zoom);
	}
}
```

**Keyboard shortcut:**

```typescript
// Add to keyboard handler
case 'f':
case 'F':
  if (!event.ctrlKey && !event.metaKey) {
    event.preventDefault();
    fitAll();
  }
  break;
```

**Commit:** `feat(canvas): add Fit All zoom button`

---

## Phase 2: Core Features

### P04: Rear View Data Model

**Goal:** Extend data model to support front/rear rack views and device face assignment.

**Dependencies:** None (data model is independent)

**Files to modify:**

- `src/lib/types/rack.ts` (extend interfaces)
- `src/lib/stores/layout.svelte.ts` (handle defaults)

**Spec reference:** v0.2 Section 3.1.1

**Tests first:**

```typescript
// src/lib/types/rack.test.ts
import { describe, it, expect } from 'vitest';
import type { Rack, PlacedDevice } from './rack';

describe('Rack type', () => {
	it('accepts view property', () => {
		const rack: Rack = {
			id: '1',
			name: 'Test',
			units: 42,
			x: 0,
			y: 0,
			view: 'front'
		};
		expect(rack.view).toBe('front');
	});

	it('accepts rear view', () => {
		const rack: Rack = {
			id: '1',
			name: 'Test',
			units: 42,
			x: 0,
			y: 0,
			view: 'rear'
		};
		expect(rack.view).toBe('rear');
	});
});

describe('PlacedDevice type', () => {
	it('accepts face property', () => {
		const device: PlacedDevice = {
			id: '1',
			deviceId: 'dev1',
			startU: 1,
			face: 'front'
		};
		expect(device.face).toBe('front');
	});

	it('accepts both face for full-depth devices', () => {
		const device: PlacedDevice = {
			id: '1',
			deviceId: 'dev1',
			startU: 1,
			face: 'both'
		};
		expect(device.face).toBe('both');
	});
});
```

**Implementation:**

```typescript
// src/lib/types/rack.ts

export type RackView = 'front' | 'rear';
export type DeviceFace = 'front' | 'rear' | 'both';

export interface Rack {
	id: string;
	name: string;
	units: number;
	x: number;
	y: number;
	view: RackView; // New in v0.2
	devices: PlacedDevice[];
}

export interface PlacedDevice {
	id: string;
	deviceId: string;
	startU: number;
	face: DeviceFace; // New in v0.2
}

// Default values for backward compatibility
export const DEFAULT_RACK_VIEW: RackView = 'front';
export const DEFAULT_DEVICE_FACE: DeviceFace = 'front';
```

**Commit:** `feat(data): add rear view data model`

---

### P05: Rear View Toggle UI

**Goal:** Add segmented control to toggle between front/rear rack view.

**Dependencies:** P04 (requires view property in data model)

**Files to modify:**

- `src/lib/components/RackHeader.svelte` (new component or extend Rack)
- `src/lib/components/Rack.svelte` (filter devices by view)

**Spec reference:** v0.2 Section 3.1.2

**Tests first:**

```typescript
// src/lib/components/RackHeader.test.ts
import { describe, it, expect } from 'vitest';
import { render, fireEvent } from '@testing-library/svelte';
import RackHeader from './RackHeader.svelte';

describe('RackHeader view toggle', () => {
	it('renders front/rear segmented control', () => {
		const { getByRole } = render(RackHeader, {
			props: { rack: { view: 'front' } }
		});
		expect(getByRole('button', { name: 'Front' })).toBeTruthy();
		expect(getByRole('button', { name: 'Rear' })).toBeTruthy();
	});

	it('highlights current view', () => {
		const { getByRole } = render(RackHeader, {
			props: { rack: { view: 'front' } }
		});
		const frontBtn = getByRole('button', { name: 'Front' });
		expect(frontBtn).toHaveAttribute('aria-pressed', 'true');
	});

	it('emits view change on click', async () => {
		const { getByRole, component } = render(RackHeader, {
			props: { rack: { view: 'front' } }
		});

		let newView: string | undefined;
		component.$on('viewchange', (e) => {
			newView = e.detail;
		});

		await fireEvent.click(getByRole('button', { name: 'Rear' }));
		expect(newView).toBe('rear');
	});
});
```

**Implementation:**

```svelte
<!-- src/lib/components/RackViewToggle.svelte -->
<script lang="ts">
	import type { RackView } from '$lib/types/rack';

	interface Props {
		view: RackView;
		onchange: (view: RackView) => void;
	}

	let { view, onchange }: Props = $props();
</script>

<div class="view-toggle" role="group" aria-label="Rack view">
	<button
		class="toggle-segment"
		class:active={view === 'front'}
		aria-pressed={view === 'front'}
		onclick={() => onchange('front')}
	>
		Front
	</button>
	<button
		class="toggle-segment"
		class:active={view === 'rear'}
		aria-pressed={view === 'rear'}
		onclick={() => onchange('rear')}
	>
		Rear
	</button>
</div>

<style>
	.view-toggle {
		display: flex;
		border: 1px solid var(--colour-border);
		border-radius: 4px;
		overflow: hidden;
	}

	.toggle-segment {
		padding: 4px 12px;
		border: none;
		background: var(--colour-surface);
		cursor: pointer;
		font-size: 12px;
	}

	.toggle-segment:not(:last-child) {
		border-right: 1px solid var(--colour-border);
	}

	.toggle-segment.active {
		background: var(--colour-selection);
		color: var(--colour-on-selection);
	}

	.toggle-segment:hover:not(.active) {
		background: var(--colour-surface-hover);
	}
</style>
```

**Device filtering in Rack.svelte:**

```typescript
// Filter devices based on current view
let visibleDevices = $derived(
	rack.devices.filter((device) => device.face === 'both' || device.face === rack.view)
);
```

**Commit:** `feat(ui): add front/rear rack view toggle`

---

### P06: Device Face Assignment

**Goal:** Allow users to assign devices to front, rear, or both faces.

**Dependencies:** P04 (requires face property in data model)

**Files to modify:**

- `src/lib/components/EditPanel.svelte` (add face selector)
- `src/lib/components/Device.svelte` (show full-depth indicator)

**Spec reference:** v0.2 Section 3.1.3

**Tests first:**

```typescript
// src/lib/components/EditPanel.test.ts (additions)
describe('Device face assignment', () => {
	it('shows face selector when device selected', () => {
		const { getByLabelText } = render(EditPanel, {
			props: { selectedDevice: mockDevice }
		});
		expect(getByLabelText('Front')).toBeTruthy();
		expect(getByLabelText('Rear')).toBeTruthy();
		expect(getByLabelText('Both (full-depth)')).toBeTruthy();
	});

	it('updates device face on selection', async () => {
		const { getByLabelText } = render(EditPanel, {
			props: { selectedDevice: mockDevice }
		});

		await fireEvent.click(getByLabelText('Both (full-depth)'));
		expect(mockDevice.face).toBe('both');
	});
});
```

**Implementation:**

```svelte
<!-- In EditPanel.svelte, add to device properties section -->
<fieldset class="face-selector">
	<legend>Mounted Face</legend>
	<label>
		<input
			type="radio"
			name="device-face"
			value="front"
			checked={selectedDevice.face === 'front'}
			onchange={() => updateDeviceFace('front')}
		/>
		Front
	</label>
	<label>
		<input
			type="radio"
			name="device-face"
			value="rear"
			checked={selectedDevice.face === 'rear'}
			onchange={() => updateDeviceFace('rear')}
		/>
		Rear
	</label>
	<label>
		<input
			type="radio"
			name="device-face"
			value="both"
			checked={selectedDevice.face === 'both'}
			onchange={() => updateDeviceFace('both')}
		/>
		Both (full-depth)
	</label>
</fieldset>
```

**Full-depth indicator in Device.svelte:**

```svelte
{#if device.face === 'both'}
	<span class="depth-indicator" title="Full-depth device">↔</span>
{/if}
```

**Commit:** `feat(devices): add face assignment for front/rear mounting`

---

### P07: Rack Duplication

**Goal:** Allow users to duplicate racks with all their devices.

**Dependencies:** None (independent feature)

**Files to modify:**

- `src/lib/components/RackContextMenu.svelte` (add duplicate option)
- `src/lib/stores/layout.svelte.ts` (add duplicateRack function)
- `src/lib/utils/rack.ts` (deep copy logic)

**Spec reference:** v0.2 Section 3.3

**Tests first:**

```typescript
// src/lib/utils/rack.test.ts
import { describe, it, expect } from 'vitest';
import { duplicateRack } from './rack';

describe('duplicateRack', () => {
	it('creates deep copy with new UUID', () => {
		const original = { id: 'rack-1', name: 'Main', devices: [] };
		const copy = duplicateRack(original);

		expect(copy.id).not.toBe(original.id);
		expect(copy.name).toBe('Main (Copy)');
	});

	it('copies all devices with new UUIDs', () => {
		const original = {
			id: 'rack-1',
			name: 'Main',
			devices: [{ id: 'dev-1', deviceId: 'lib-1', startU: 1, face: 'front' }]
		};
		const copy = duplicateRack(original);

		expect(copy.devices).toHaveLength(1);
		expect(copy.devices[0].id).not.toBe('dev-1');
		expect(copy.devices[0].deviceId).toBe('lib-1'); // Same library reference
		expect(copy.devices[0].startU).toBe(1);
	});

	it('positions copy to the right of original', () => {
		const original = { id: 'rack-1', x: 100, y: 50 };
		const copy = duplicateRack(original);

		expect(copy.x).toBeGreaterThan(original.x);
		expect(copy.y).toBe(original.y);
	});
});

// src/lib/stores/layout.test.ts (additions)
describe('layout store duplication', () => {
	it('rejects duplication when 6 racks exist', () => {
		// Setup 6 racks
		const result = layoutStore.duplicateRack('rack-1');
		expect(result.error).toBe('Maximum of 6 racks allowed');
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/rack.ts

import { v4 as uuid } from 'uuid';
import type { Rack, PlacedDevice } from '$lib/types/rack';
import { RACK_WIDTH, RACK_GAP } from '$lib/constants';

export function duplicateRack(original: Rack): Rack {
	const newDevices: PlacedDevice[] = original.devices.map((device) => ({
		...device,
		id: uuid()
	}));

	return {
		...original,
		id: uuid(),
		name: `${original.name} (Copy)`,
		x: original.x + RACK_WIDTH + RACK_GAP,
		devices: newDevices
	};
}
```

**Context menu addition:**

```svelte
<!-- In RackContextMenu.svelte -->
<button onclick={handleDuplicate}> Duplicate Rack </button>
```

**Keyboard shortcut:**

```typescript
// Ctrl/Cmd + D when rack selected
if ((event.ctrlKey || event.metaKey) && event.key === 'd') {
	event.preventDefault();
	if (selectedRack) {
		duplicateRack(selectedRack.id);
	}
}
```

**Commit:** `feat(racks): add rack duplication`

---

## Phase 3: UI Polish

### P08: Device Library Toggle Button

**Goal:** Replace branding area with functional Device Library toggle button.

**Dependencies:** None (independent UI change)

**Files to modify:**

- `src/lib/components/Toolbar.svelte` (update leftmost element)
- `src/lib/assets/` (ensure Rackarr icon available)

**Spec reference:** v0.2 Section 2.2

**Tests first:**

```typescript
// src/lib/components/Toolbar.test.ts (additions)
describe('Device Library toggle', () => {
	it('renders icon and "Device Library" text', () => {
		const { getByRole } = render(Toolbar);
		const toggle = getByRole('button', { name: /device library/i });
		expect(toggle).toBeTruthy();
	});

	it('toggles drawer on click', async () => {
		const { getByRole } = render(Toolbar);
		const toggle = getByRole('button', { name: /device library/i });

		await fireEvent.click(toggle);
		expect(toggle).toHaveAttribute('aria-expanded', 'true');
	});

	it('shows active state when drawer open', async () => {
		const { getByRole } = render(Toolbar);
		const toggle = getByRole('button', { name: /device library/i });

		await fireEvent.click(toggle);
		expect(toggle.classList.contains('active')).toBe(true);
	});

	it('has correct aria attributes', () => {
		const { getByRole } = render(Toolbar);
		const toggle = getByRole('button', { name: /device library/i });

		expect(toggle).toHaveAttribute('aria-controls', 'device-library-drawer');
		expect(toggle).toHaveAttribute('aria-expanded');
	});
});
```

**Implementation:**

```svelte
<!-- In Toolbar.svelte -->
<button
	class="device-library-toggle"
	class:active={isDrawerOpen}
	aria-expanded={isDrawerOpen}
	aria-controls="device-library-drawer"
	onclick={toggleDrawer}
>
	<RackarrIcon class="icon" />
	<span>Device Library</span>
</button>

<style>
	.device-library-toggle {
		display: flex;
		align-items: center;
		gap: 8px;
		padding: 8px 12px;
		border-radius: 4px;
		background: transparent;
		border: none;
		cursor: pointer;
		transition: background-color var(--transition-fast);
	}

	.device-library-toggle:hover {
		background: var(--colour-surface-hover);
	}

	.device-library-toggle.active {
		background: color-mix(in srgb, var(--colour-selection) 20%, transparent);
	}

	.device-library-toggle :global(.icon) {
		height: 20px;
		width: auto;
	}
</style>
```

**Commit:** `feat(toolbar): add Device Library toggle button`

---

### P09: Device Library Drawer Changes

**Goal:** Remove X close button from drawer; closing via toggle, Escape, or D key only.

**Dependencies:** P08 (toggle button must exist)

**Files to modify:**

- `src/lib/components/DeviceLibraryDrawer.svelte` (remove close button)

**Spec reference:** v0.2 Section 2.3

**Tests first:**

```typescript
// src/lib/components/DeviceLibraryDrawer.test.ts (additions)
describe('Drawer closing', () => {
	it('does not render X close button', () => {
		const { queryByLabelText } = render(DeviceLibraryDrawer, {
			props: { open: true }
		});
		expect(queryByLabelText('Close')).toBeNull();
	});

	it('closes on Escape key', async () => {
		const { component } = render(DeviceLibraryDrawer, {
			props: { open: true }
		});

		await fireEvent.keyDown(document, { key: 'Escape' });
		// Verify close event emitted
	});

	it('closes on D key', async () => {
		const { component } = render(DeviceLibraryDrawer, {
			props: { open: true }
		});

		await fireEvent.keyDown(document, { key: 'd' });
		// Verify close event emitted
	});
});
```

**Implementation:**

Remove the close button from drawer header. Ensure keyboard handlers are in place.

**Commit:** `refactor(drawer): remove X close button, use toggle/Escape/D`

---

### P10: Rack Title Above Rack

**Goal:** Move rack title from below to above the rack.

**Dependencies:** None (independent rendering change)

**Files to modify:**

- `src/lib/components/Rack.svelte` (reposition title)
- `src/lib/utils/export.ts` (update export rendering)

**Spec reference:** v0.2 Section 2.5

**Tests first:**

```typescript
// src/lib/components/Rack.test.ts (additions)
describe('Rack title positioning', () => {
	it('renders title above rack', () => {
		const { container } = render(Rack, { props: { rack: mockRack } });
		const title = container.querySelector('.rack-title');
		const rackBody = container.querySelector('.rack-body');

		// Title Y should be less than rack body Y (above)
		const titleY = parseFloat(title?.getAttribute('y') ?? '0');
		const bodyY = parseFloat(rackBody?.getAttribute('y') ?? '0');
		expect(titleY).toBeLessThan(bodyY);
	});
});

// src/lib/utils/export.test.ts (additions)
describe('Export title positioning', () => {
	it('exports title above rack', () => {
		const svg = exportRackToSVG(mockRack);
		// Parse SVG and verify title position
	});
});
```

**Implementation:**

```svelte
<!-- In Rack.svelte -->
<text class="rack-title" x={rackWidth / 2} y={-8} text-anchor="middle" dominant-baseline="auto">
	{rack.name}
</text>
```

**Commit:** `fix(ui): position rack title above rack`

---

### P11: Device Icon Vertical Alignment

**Goal:** Vertically centre category icons within device rectangles.

**Dependencies:** None (independent rendering fix)

**Files to modify:**

- `src/lib/components/Device.svelte` (CSS fix)
- `src/lib/utils/export.ts` (SVG rendering fix)

**Spec reference:** v0.2 Section 2.6

**Tests first:**

```typescript
// Visual regression test or manual verification
describe('Device icon alignment', () => {
	it('centres icon vertically in device', () => {
		const { container } = render(Device, { props: { device: mockDevice } });
		const content = container.querySelector('.device-content');
		const styles = getComputedStyle(content!);
		expect(styles.alignItems).toBe('center');
	});
});
```

**Implementation:**

```css
/* In Device.svelte */
.device-content {
	display: flex;
	align-items: center;
	justify-content: flex-start;
	height: 100%;
}
```

For SVG export:

```typescript
// Icon vertical position — centre of device
const iconY = deviceY + deviceHeight / 2;
// Use dominant-baseline="middle" for text/icons
```

**Commit:** `fix(ui): vertically centre device icons`

---

### P12: Help Panel Update

**Goal:** Remove Forgejo link, keep GitHub as primary repository link.

**Dependencies:** None (independent content change)

**Files to modify:**

- `src/lib/components/HelpPanel.svelte` (remove Forgejo link)

**Spec reference:** v0.2 Section 2.4

**Tests first:**

```typescript
// src/lib/components/HelpPanel.test.ts (additions)
describe('Help panel links', () => {
	it('shows GitHub repository link', () => {
		const { getByRole } = render(HelpPanel);
		expect(getByRole('link', { name: /github/i })).toBeTruthy();
	});

	it('does not show Forgejo link', () => {
		const { queryByRole } = render(HelpPanel);
		expect(queryByRole('link', { name: /forgejo/i })).toBeNull();
	});
});
```

**Implementation:**

Remove the Forgejo link from HelpPanel.svelte.

**Commit:** `docs(help): remove internal Forgejo link`

---

## Phase 4: Data & Migration

### P13: Device Library Import

**Goal:** Allow importing device library from JSON file.

**Dependencies:** None (independent feature)

**Files to modify:**

- `src/lib/components/DeviceLibraryDrawer.svelte` (add Import button)
- `src/lib/utils/import.ts` (validation and merge logic)
- `src/lib/stores/devices.svelte.ts` (merge imported devices)

**Spec reference:** v0.2 Section 3.4

**Tests first:**

```typescript
// src/lib/utils/import.test.ts
import { describe, it, expect } from 'vitest';
import { parseDeviceLibraryImport, validateDevice } from './import';

describe('parseDeviceLibraryImport', () => {
	it('parses valid JSON', () => {
		const json = JSON.stringify({
			name: 'My Library',
			devices: [{ name: 'Server', height: 2, category: 'server' }]
		});
		const result = parseDeviceLibraryImport(json);
		expect(result.devices).toHaveLength(1);
	});

	it('skips invalid entries', () => {
		const json = JSON.stringify({
			devices: [
				{ name: 'Valid', height: 2, category: 'server' },
				{ name: 'Invalid', height: -1, category: 'server' }, // Invalid height
				{ name: 'Also Invalid', height: 2, category: 'fake' } // Invalid category
			]
		});
		const result = parseDeviceLibraryImport(json);
		expect(result.devices).toHaveLength(1);
		expect(result.skipped).toBe(2);
	});

	it('handles duplicate names', () => {
		const existingNames = ['Server'];
		const json = JSON.stringify({
			devices: [{ name: 'Server', height: 2, category: 'server' }]
		});
		const result = parseDeviceLibraryImport(json, existingNames);
		expect(result.devices[0].name).toBe('Server (imported)');
	});
});

describe('validateDevice', () => {
	it('rejects height < 0.5', () => {
		expect(validateDevice({ height: 0.4 })).toBe(false);
	});

	it('rejects height > 100', () => {
		expect(validateDevice({ height: 101 })).toBe(false);
	});

	it('rejects invalid category', () => {
		expect(validateDevice({ category: 'invalid' })).toBe(false);
	});

	it('accepts valid device', () => {
		expect(
			validateDevice({
				name: 'Test',
				height: 2,
				category: 'server'
			})
		).toBe(true);
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/import.ts

import type { LibraryDevice } from '$lib/types/device';
import { VALID_CATEGORIES } from '$lib/constants';

interface ImportResult {
	devices: LibraryDevice[];
	skipped: number;
}

export function validateDevice(device: Partial<LibraryDevice>): boolean {
	if (!device.name || typeof device.name !== 'string') return false;
	if (typeof device.height !== 'number' || device.height < 0.5 || device.height > 100) return false;
	if (!device.category || !VALID_CATEGORIES.includes(device.category)) return false;
	return true;
}

export function parseDeviceLibraryImport(json: string, existingNames: string[] = []): ImportResult {
	const data = JSON.parse(json);
	const devices: LibraryDevice[] = [];
	let skipped = 0;

	for (const entry of data.devices ?? []) {
		if (!validateDevice(entry)) {
			skipped++;
			continue;
		}

		let name = entry.name;
		if (existingNames.includes(name)) {
			name = `${name} (imported)`;
		}

		devices.push({
			id: uuid(),
			name,
			height: entry.height,
			category: entry.category,
			colour: entry.colour ?? getDefaultColour(entry.category),
			notes: entry.notes ?? ''
		});
	}

	return { devices, skipped };
}
```

**Toast notification:**

```typescript
showToast(`Imported ${result.devices.length} devices (${result.skipped} skipped)`);
```

**Commit:** `feat(library): add device library import from JSON`

---

### P14: v0.1 to v0.2 Migration

**Goal:** Handle loading v0.1 layouts with appropriate defaults for new fields.

**Dependencies:** P04 (requires new data model fields defined)

**Files to modify:**

- `src/lib/utils/layout.ts` (migration logic)
- `src/lib/stores/layout.svelte.ts` (apply migration on load)

**Spec reference:** v0.2 Section 6

**Tests first:**

```typescript
// src/lib/utils/layout.test.ts
import { describe, it, expect } from 'vitest';
import { migrateLayout } from './layout';

describe('migrateLayout', () => {
	it('adds view: front to v0.1 racks', () => {
		const v01Layout = {
			version: '0.1.0',
			racks: [{ id: '1', name: 'Test', units: 42 }]
		};
		const result = migrateLayout(v01Layout);
		expect(result.racks[0].view).toBe('front');
	});

	it('adds face: front to v0.1 devices', () => {
		const v01Layout = {
			version: '0.1.0',
			racks: [
				{
					id: '1',
					devices: [{ id: 'd1', startU: 1 }]
				}
			]
		};
		const result = migrateLayout(v01Layout);
		expect(result.racks[0].devices[0].face).toBe('front');
	});

	it('preserves v0.2 layouts unchanged', () => {
		const v02Layout = {
			version: '0.2.0',
			racks: [
				{
					id: '1',
					view: 'rear',
					devices: [{ id: 'd1', face: 'both' }]
				}
			]
		};
		const result = migrateLayout(v02Layout);
		expect(result.racks[0].view).toBe('rear');
		expect(result.racks[0].devices[0].face).toBe('both');
	});

	it('updates version to 0.2.0', () => {
		const v01Layout = { version: '0.1.0', racks: [] };
		const result = migrateLayout(v01Layout);
		expect(result.version).toBe('0.2.0');
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/layout.ts

import type { Layout } from '$lib/types/layout';
import { DEFAULT_RACK_VIEW, DEFAULT_DEVICE_FACE } from '$lib/types/rack';

export function migrateLayout(layout: Layout): Layout {
	const version = layout.version ?? '0.1.0';

	if (version.startsWith('0.2')) {
		return layout; // Already v0.2, no migration needed
	}

	// v0.1 → v0.2 migration
	const migratedRacks = layout.racks.map((rack) => ({
		...rack,
		view: rack.view ?? DEFAULT_RACK_VIEW,
		devices: rack.devices.map((device) => ({
			...device,
			face: device.face ?? DEFAULT_DEVICE_FACE
		}))
	}));

	return {
		...layout,
		version: '0.2.0',
		racks: migratedRacks
	};
}
```

**Commit:** `feat(migration): add v0.1 to v0.2 layout migration`

---

## Success Criteria Checklist

After completing all prompts, verify:

### Core Features

- [ ] User can toggle between front/rear rack view
- [ ] Devices can be assigned to front, rear, or both faces
- [ ] "Fit All" zooms canvas to show all racks
- [ ] Racks can be duplicated with all devices
- [ ] Device library can be imported from JSON

### UI Polish

- [ ] Device Library button (with Rackarr icon) toggles drawer
- [ ] Device Library drawer has no X close button
- [ ] Rack titles appear above racks (canvas and export)
- [ ] Device icons are vertically centred
- [ ] Help panel shows only GitHub link (no Forgejo)

### Technical Foundation

- [ ] panzoom library integrated for canvas zoom/pan
- [ ] Coordinate handling uses getScreenCTM() for transform-aware positioning
- [ ] Drag-and-drop works correctly at all zoom levels and pan positions

### Compatibility

- [ ] All existing v0.1 functionality preserved
- [ ] v0.1 layouts load correctly with appropriate defaults

---

## Related Documents

- [[v0.2-spec|v0.2 Specification]]
- [[spec|Base Specification (v0.1)]]
- [[prompt_plan|v0.1 Prompt Plan]]
- [[todo|Progress Checklist]]

---

_Execute prompts in order. Each prompt includes tests-first approach per TDD protocol._
