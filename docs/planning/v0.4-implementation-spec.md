# Rackarr v0.4 Implementation Specification

**Status:** Ready for Implementation
**Date:** 2025-12-03
**Target Version:** v0.4.0

---

## Table of Contents

1. [Overview](#1-overview)
2. [Requirements](#2-requirements)
3. [Architecture](#3-architecture)
4. [Data Schemas](#4-data-schemas)
5. [File Format](#5-file-format)
6. [Implementation Tasks](#6-implementation-tasks)
7. [Error Handling](#7-error-handling)
8. [Migration Strategy](#8-migration-strategy)
9. [Testing Plan](#9-testing-plan)
10. [Acceptance Criteria](#10-acceptance-criteria)

---

## 1. Overview

### 1.1 Purpose

Refactor Rackarr's data layer to:

- Adopt NetBox-compatible naming conventions
- Use YAML for human-readable project files
- Implement folder-based project structure
- Establish consistent snake_case naming throughout

### 1.2 Scope

| In Scope                         | Out of Scope            |
| -------------------------------- | ----------------------- |
| TypeScript interface refactoring | Multi-rack support      |
| YAML serialization               | NetBox import feature   |
| Folder-based save format         | Cloud storage           |
| Backward-compatible file loading | Real-time collaboration |
| Zod schema updates               |                         |

### 1.3 Key Changes Summary

| Current         | Target                          |
| --------------- | ------------------------------- |
| `Device`        | `DeviceType` (library template) |
| `PlacedDevice`  | `Device` (placed instance)      |
| `height`        | `u_height`                      |
| `libraryId`     | `device_type` (slug)            |
| `id` (UUID)     | `slug` (human-readable)         |
| `.rackarr.zip`  | `[name]/[name].yaml` folder     |
| JSON internally | YAML for persistence            |
| camelCase/mixed | snake_case throughout           |

---

## 2. Requirements

### 2.1 Functional Requirements

#### FR-1: File Format

- **FR-1.1**: Save projects as folder structure: `[rack-name]/[rack-name].yaml`
- **FR-1.2**: Store device images in `[rack-name]/assets/[device-slug]/[face].[ext]`
- **FR-1.3**: Support loading legacy `.rackarr.zip` files
- **FR-1.4**: Support loading legacy `.rackarr.json` files
- **FR-1.5**: Provide "Export as ZIP" option for sharing

#### FR-2: Device Types

- **FR-2.1**: DeviceType requires unique `slug` field
- **FR-2.2**: Auto-generate slug from name if not provided
- **FR-2.3**: Validate slug uniqueness within project
- **FR-2.4**: Support optional `manufacturer` and `model` fields

#### FR-3: Placed Devices

- **FR-3.1**: Reference DeviceType via `device_type` slug field
- **FR-3.2**: Support optional `name` for display override
- **FR-3.3**: Display falls back to DeviceType name if `name` not set

#### FR-4: Naming Conventions

- **FR-4.1**: All persisted fields use snake_case
- **FR-4.2**: TypeScript interfaces use snake_case (matching persistence)
- **FR-4.3**: Height field named `u_height`

### 2.2 Non-Functional Requirements

#### NFR-1: Performance

- File save/load under 500ms for typical projects (< 50 devices)
- No UI freeze during file operations

#### NFR-2: Compatibility

- Graceful loading of v0.1-v0.3 files with automatic migration
- No data loss during migration

#### NFR-3: Usability

- Human-readable YAML output (proper indentation, comments where helpful)
- Meaningful error messages for validation failures

---

## 3. Architecture

### 3.1 Layer Overview

```
┌─────────────────────────────────────────────────────────┐
│                    UI Components                         │
│  (Rack.svelte, DevicePalette.svelte, EditPanel.svelte)  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                    Stores (Svelte 5 Runes)              │
│         layout.svelte.ts, selection.svelte.ts           │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   Domain Logic                           │
│     utils/rack.ts, utils/device.ts, utils/collision.ts  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                 Serialization Layer                      │
│   utils/serialization.ts, utils/yaml.ts (NEW)           │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   File I/O Layer                         │
│        utils/file.ts, utils/archive.ts                  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                 Validation Layer                         │
│              schemas/device.ts (Zod)                    │
└─────────────────────────────────────────────────────────┘
```

### 3.2 New/Modified Files

```
src/lib/
├── types/
│   └── index.ts              # MODIFY: Rename interfaces, snake_case
├── schemas/
│   └── device.ts             # MODIFY: Update Zod schemas
├── utils/
│   ├── yaml.ts               # NEW: YAML serialization
│   ├── slug.ts               # NEW: Slug generation/validation
│   ├── serialization.ts      # MODIFY: Use YAML, new structure
│   ├── file.ts               # MODIFY: Folder-based save
│   ├── archive.ts            # MODIFY: New image structure
│   └── migration.ts          # MODIFY: v0.3 → v0.4 migration
└── stores/
    └── layout.svelte.ts      # MODIFY: Use new type names
```

### 3.3 Dependencies

**New dependency:**

```json
{
	"dependencies": {
		"js-yaml": "^4.1.0"
	},
	"devDependencies": {
		"@types/js-yaml": "^4.0.9"
	}
}
```

---

## 4. Data Schemas

### 4.1 TypeScript Interfaces

```typescript
// src/lib/types/index.ts

/**
 * Device category for UI filtering
 */
export type DeviceCategory =
	| 'server'
	| 'storage'
	| 'networking'
	| 'power'
	| 'cooling'
	| 'kvm'
	| 'audio-video'
	| 'security'
	| 'cable-management'
	| 'accessories'
	| 'other'
	| 'shelf';

/**
 * Rack form factor
 */
export type FormFactor = '2-post' | '4-post' | '4-post-cabinet' | 'wall-mount' | 'open-frame';

/**
 * Airflow direction (NetBox-compatible)
 */
export type Airflow =
	| 'front-to-rear'
	| 'rear-to-front'
	| 'left-to-right'
	| 'right-to-left'
	| 'side-to-rear'
	| 'passive';

/**
 * Device face in rack
 */
export type DeviceFace = 'front' | 'rear' | 'both';

/**
 * Rack view (runtime only, not persisted)
 */
export type RackView = 'front' | 'rear';

/**
 * Weight unit
 */
export type WeightUnit = 'kg' | 'lb';

/**
 * Rackarr-specific extensions to DeviceType
 */
export interface RackarrDeviceTypeExtensions {
	colour: string; // Hex colour for display
	category: DeviceCategory; // For UI filtering
	tags?: string[]; // User organization
}

/**
 * Device Type - template definition in library
 * NetBox-compatible with Rackarr extensions
 */
export interface DeviceType {
	// Required fields
	slug: string; // Unique identifier, kebab-case
	u_height: number; // Height in rack units

	// Optional NetBox fields
	manufacturer?: string;
	model?: string;
	is_full_depth?: boolean;
	weight?: number;
	weight_unit?: WeightUnit;
	airflow?: Airflow;
	comments?: string;

	// Rackarr extensions
	rackarr: RackarrDeviceTypeExtensions;
}

/**
 * Device - placed instance in rack
 */
export interface Device {
	device_type: string; // Slug reference to DeviceType
	name?: string; // Optional display name override
	position: number; // U position (bottom of device)
	face: DeviceFace;
}

/**
 * Rack definition
 */
export interface Rack {
	name: string;
	height: number; // Total U height
	width: 10 | 19; // Rack width in inches
	desc_units: boolean; // True = number from top down
	form_factor: FormFactor;
	starting_unit: number; // First U number (usually 1)
	position: number; // Order in layout (persisted)
	devices: Device[];

	// Runtime only (not persisted)
	view?: RackView;
}

/**
 * Display mode for device rendering
 */
export type DisplayMode = 'label' | 'image';

/**
 * Layout settings
 */
export interface LayoutSettings {
	display_mode: DisplayMode;
	show_labels_on_images: boolean;
}

/**
 * Complete layout/project
 */
export interface Layout {
	version: string;
	name: string;
	rack: Rack; // Single rack (v0.4)
	device_types: DeviceType[];
	settings: LayoutSettings;
}
```

### 4.2 Zod Validation Schemas

```typescript
// src/lib/schemas/device.ts

import { z } from 'zod';

/**
 * Slug pattern: lowercase alphanumeric with hyphens
 * Examples: "synology-ds920-plus", "custom-2u-server"
 */
const slugPattern = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;

export const SlugSchema = z
	.string()
	.min(1, 'Slug is required')
	.max(100, 'Slug too long')
	.regex(slugPattern, 'Slug must be lowercase with hyphens only');

export const DeviceCategorySchema = z.enum([
	'server',
	'storage',
	'networking',
	'power',
	'cooling',
	'kvm',
	'audio-video',
	'security',
	'cable-management',
	'accessories',
	'other',
	'shelf'
]);

export const FormFactorSchema = z.enum([
	'2-post',
	'4-post',
	'4-post-cabinet',
	'wall-mount',
	'open-frame'
]);

export const AirflowSchema = z.enum([
	'front-to-rear',
	'rear-to-front',
	'left-to-right',
	'right-to-left',
	'side-to-rear',
	'passive'
]);

export const DeviceFaceSchema = z.enum(['front', 'rear', 'both']);

export const WeightUnitSchema = z.enum(['kg', 'lb']);

export const RackarrExtensionsSchema = z.object({
	colour: z.string().regex(/^#[0-9a-fA-F]{6}$/, 'Invalid hex colour'),
	category: DeviceCategorySchema,
	tags: z.array(z.string()).optional()
});

export const DeviceTypeSchema = z.object({
	slug: SlugSchema,
	u_height: z.number().int().min(1).max(50),
	manufacturer: z.string().max(100).optional(),
	model: z.string().max(100).optional(),
	is_full_depth: z.boolean().optional(),
	weight: z.number().positive().optional(),
	weight_unit: WeightUnitSchema.optional(),
	airflow: AirflowSchema.optional(),
	comments: z.string().max(1000).optional(),
	rackarr: RackarrExtensionsSchema
});

export const DeviceSchema = z.object({
	device_type: SlugSchema,
	name: z.string().max(100).optional(),
	position: z.number().int().min(1),
	face: DeviceFaceSchema
});

export const RackSchema = z.object({
	name: z.string().min(1).max(100),
	height: z.number().int().min(1).max(50),
	width: z.union([z.literal(10), z.literal(19)]),
	desc_units: z.boolean(),
	form_factor: FormFactorSchema,
	starting_unit: z.number().int().min(1),
	position: z.number().int().min(0),
	devices: z.array(DeviceSchema)
});

export const LayoutSettingsSchema = z.object({
	display_mode: z.enum(['label', 'image']),
	show_labels_on_images: z.boolean()
});

export const LayoutSchema = z.object({
	version: z.string(),
	name: z.string().min(1).max(100),
	rack: RackSchema,
	device_types: z.array(DeviceTypeSchema),
	settings: LayoutSettingsSchema
});

/**
 * Validate slug uniqueness within device_types array
 */
export function validateSlugUniqueness(device_types: { slug: string }[]): string[] {
	const slugs = new Map<string, number>();
	const duplicates: string[] = [];

	for (const dt of device_types) {
		const count = slugs.get(dt.slug) || 0;
		if (count > 0) {
			duplicates.push(dt.slug);
		}
		slugs.set(dt.slug, count + 1);
	}

	return duplicates;
}
```

---

## 5. File Format

### 5.1 Folder Structure

```
homelab-rack/
├── homelab-rack.yaml         # Main project file
└── assets/
    ├── synology-ds920-plus/
    │   ├── front.png
    │   └── rear.jpg
    ├── ubiquiti-usg-pro-4/
    │   └── front.png
    └── custom-patch-panel/
        └── front.png
```

### 5.2 YAML Schema

```yaml
# homelab-rack/homelab-rack.yaml
version: '0.4.0'
name: Homelab Rack

rack:
  name: Homelab Rack
  height: 42
  width: 19
  desc_units: false
  form_factor: 4-post-cabinet
  starting_unit: 1
  position: 0
  devices:
    - device_type: synology-ds920-plus
      name: Primary NAS
      position: 10
      face: front

    - device_type: ubiquiti-usg-pro-4
      position: 40
      face: front

    - device_type: custom-patch-panel
      position: 42
      face: front

device_types:
  - slug: synology-ds920-plus
    manufacturer: Synology
    model: DS920+
    u_height: 2
    is_full_depth: true
    airflow: front-to-rear
    comments: '4-bay NAS for media storage'
    rackarr:
      colour: '#10b981'
      category: storage
      tags:
        - nas
        - synology

  - slug: ubiquiti-usg-pro-4
    manufacturer: Ubiquiti
    model: USG-Pro-4
    u_height: 1
    rackarr:
      colour: '#3b82f6'
      category: networking

  - slug: custom-patch-panel
    u_height: 1
    rackarr:
      colour: '#6b7280'
      category: networking

settings:
  display_mode: label
  show_labels_on_images: true
```

### 5.3 Image Naming Convention

| Pattern                     | Example                                |
| --------------------------- | -------------------------------------- |
| `assets/{slug}/front.{ext}` | `assets/synology-ds920-plus/front.png` |
| `assets/{slug}/rear.{ext}`  | `assets/synology-ds920-plus/rear.jpg`  |

**Supported extensions:** `.png`, `.jpg`, `.jpeg`, `.webp`, `.svg`

### 5.4 Legacy Format Support

| Format        | Extension            | Support    |
| ------------- | -------------------- | ---------- |
| v0.4 Folder   | `[name]/[name].yaml` | Read/Write |
| v0.3 Archive  | `.rackarr.zip`       | Read only  |
| v0.1-0.2 JSON | `.rackarr.json`      | Read only  |

---

## 6. Implementation Tasks

### Phase 1: Core Type Refactoring

#### Task 1.1: Add Dependencies

```bash
npm install js-yaml
npm install -D @types/js-yaml
```

#### Task 1.2: Create Slug Utilities

**File:** `src/lib/utils/slug.ts`

```typescript
/**
 * Slug generation and validation utilities
 */

/**
 * Convert string to valid slug
 * "Synology DS920+" → "synology-ds920-plus"
 */
export function slugify(input: string): string {
	return input
		.toLowerCase()
		.trim()
		.replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphens
		.replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
		.replace(/-+/g, '-'); // Collapse multiple hyphens
}

/**
 * Generate slug from manufacturer and model
 */
export function generateDeviceSlug(manufacturer?: string, model?: string, name?: string): string {
	if (manufacturer && model) {
		return slugify(`${manufacturer}-${model}`);
	}
	if (name) {
		return slugify(name);
	}
	return slugify(`device-${Date.now()}`);
}

/**
 * Validate slug format
 */
export function isValidSlug(slug: string): boolean {
	return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(slug);
}

/**
 * Ensure slug is unique by appending number if needed
 */
export function ensureUniqueSlug(slug: string, existingSlugs: Set<string>): string {
	if (!existingSlugs.has(slug)) {
		return slug;
	}

	let counter = 2;
	let candidate = `${slug}-${counter}`;
	while (existingSlugs.has(candidate)) {
		counter++;
		candidate = `${slug}-${counter}`;
	}
	return candidate;
}
```

#### Task 1.3: Update Type Definitions

**File:** `src/lib/types/index.ts`

- Rename `Device` → `DeviceType`
- Rename `PlacedDevice` → `Device`
- Change `height` → `u_height`
- Change `libraryId` → `device_type`
- Change `id` → `slug`
- Add optional `name` to `Device`
- Use snake_case for all fields

#### Task 1.4: Update Zod Schemas

**File:** `src/lib/schemas/device.ts`

- Update to match new type definitions
- Add slug validation
- Add uniqueness check helper

### Phase 2: Serialization Layer

#### Task 2.1: Create YAML Utilities

**File:** `src/lib/utils/yaml.ts`

```typescript
import yaml from 'js-yaml';
import type { Layout } from '$lib/types';
import { LayoutSchema } from '$lib/schemas/device';

/**
 * Serialize Layout to YAML string
 */
export function serializeToYaml(layout: Layout): string {
	// Remove runtime-only fields before serialization
	const persistable = {
		...layout,
		rack: {
			...layout.rack,
			view: undefined // Don't persist view
		}
	};

	return yaml.dump(persistable, {
		indent: 2,
		lineWidth: 120,
		noRefs: true,
		sortKeys: false, // Preserve field order
		quotingType: '"'
	});
}

/**
 * Parse YAML string to Layout
 */
export function parseYaml(yamlString: string): Layout {
	const data = yaml.load(yamlString);

	// Validate with Zod
	const result = LayoutSchema.safeParse(data);
	if (!result.success) {
		throw new Error(`Invalid YAML: ${result.error.message}`);
	}

	// Add runtime defaults
	return {
		...result.data,
		rack: {
			...result.data.rack,
			view: 'front' // Default view
		}
	};
}
```

#### Task 2.2: Update File Operations

**File:** `src/lib/utils/file.ts`

```typescript
/**
 * Save layout as folder structure
 * Returns the folder name for toast message
 */
export async function saveAsFolder(
	layout: Layout,
	images: Map<string, DeviceImages>
): Promise<string> {
	const folderName = slugify(layout.name);
	const yamlContent = serializeToYaml(layout);

	// In browser: create ZIP containing folder structure
	// User downloads ZIP, extracts to get folder
	const zip = new JSZip();
	const folder = zip.folder(folderName);

	// Add YAML file
	folder.file(`${folderName}.yaml`, yamlContent);

	// Add images
	const assetsFolder = folder.folder('assets');
	for (const [deviceSlug, deviceImages] of images) {
		const deviceFolder = assetsFolder.folder(deviceSlug);
		if (deviceImages.front) {
			const ext = getExtension(deviceImages.front.mimeType);
			deviceFolder.file(`front.${ext}`, deviceImages.front.data);
		}
		if (deviceImages.rear) {
			const ext = getExtension(deviceImages.rear.mimeType);
			deviceFolder.file(`rear.${ext}`, deviceImages.rear.data);
		}
	}

	const blob = await zip.generateAsync({ type: 'blob' });
	downloadBlob(blob, `${folderName}.zip`);

	return folderName;
}
```

### Phase 3: Migration

#### Task 3.1: Update Migration Utility

**File:** `src/lib/utils/migration.ts`

```typescript
import { slugify, ensureUniqueSlug } from './slug';
import type { Layout, DeviceType, Device } from '$lib/types';

interface LegacyDevice {
	id: string;
	name: string;
	height: number;
	category: string;
	colour: string;
	notes?: string;
}

interface LegacyPlacedDevice {
	libraryId: string;
	position: number;
	face: 'front' | 'rear' | 'both';
}

interface LegacyLayout {
	version: string;
	name: string;
	racks: Array<{
		id: string;
		name: string;
		height: number;
		width?: number;
		devices: LegacyPlacedDevice[];
		// ... other fields
	}>;
	deviceLibrary: LegacyDevice[];
}

/**
 * Migrate v0.1-0.3 layout to v0.4 format
 */
export function migrateLayout(legacy: LegacyLayout): Layout {
	const existingSlugs = new Set<string>();
	const idToSlug = new Map<string, string>();

	// Migrate device library to device_types
	const device_types: DeviceType[] = legacy.deviceLibrary.map((device) => {
		// Generate unique slug
		let slug = slugify(device.name);
		slug = ensureUniqueSlug(slug, existingSlugs);
		existingSlugs.add(slug);
		idToSlug.set(device.id, slug);

		return {
			slug,
			u_height: device.height,
			comments: device.notes,
			rackarr: {
				colour: device.colour,
				category: device.category as DeviceCategory
			}
		};
	});

	// Migrate first rack
	const legacyRack = legacy.racks[0];
	if (!legacyRack) {
		throw new Error('No rack found in layout');
	}

	// Migrate placed devices
	const devices: Device[] = legacyRack.devices.map((placed) => ({
		device_type: idToSlug.get(placed.libraryId) || 'unknown',
		position: placed.position,
		face: placed.face
	}));

	return {
		version: '0.4.0',
		name: legacy.name,
		rack: {
			name: legacyRack.name,
			height: legacyRack.height,
			width: legacyRack.width || 19,
			desc_units: legacyRack.desc_units || false,
			form_factor: legacyRack.form_factor || '4-post-cabinet',
			starting_unit: legacyRack.starting_unit || 1,
			position: 0,
			devices,
			view: 'front'
		},
		device_types,
		settings: {
			display_mode: 'label',
			show_labels_on_images: true
		}
	};
}

/**
 * Detect layout version
 */
export function detectVersion(data: unknown): string {
	if (typeof data === 'object' && data !== null) {
		const obj = data as Record<string, unknown>;
		if (typeof obj.version === 'string') {
			return obj.version;
		}
		// Legacy detection
		if ('deviceLibrary' in obj) return '0.3.0';
		if ('racks' in obj) return '0.1.0';
	}
	return 'unknown';
}
```

### Phase 4: Store Updates

#### Task 4.1: Update Layout Store

**File:** `src/lib/stores/layout.svelte.ts`

Key changes:

- Rename all function parameters and variables
- Update `addDeviceToLibrary` → `addDeviceType`
- Update internal references from `libraryId` to `device_type`
- Generate slugs when creating device types

### Phase 5: Component Updates

Update all components that reference the old type names:

- `DevicePalette.svelte`
- `EditPanel.svelte`
- `Rack.svelte`
- `AddDeviceForm.svelte`
- `ExportDialog.svelte`

---

## 7. Error Handling

### 7.1 Validation Errors

| Error Type             | Message                                           | Action                             |
| ---------------------- | ------------------------------------------------- | ---------------------------------- |
| Invalid slug format    | "Slug must be lowercase with hyphens only"        | Highlight field, show inline error |
| Duplicate slug         | "A device type with slug '{slug}' already exists" | Suggest alternative                |
| Invalid YAML           | "Invalid project file: {details}"                 | Show toast, don't load             |
| Missing required field | "{field} is required"                             | Highlight field                    |

### 7.2 File Operation Errors

| Error Type        | Message                           | Action                            |
| ----------------- | --------------------------------- | --------------------------------- |
| File not found    | "Could not read file"             | Show toast                        |
| Invalid format    | "Unrecognized file format"        | Show toast with supported formats |
| Permission denied | "Cannot save to this location"    | Show toast                        |
| Corrupted archive | "Archive appears to be corrupted" | Show toast                        |

### 7.3 Migration Errors

| Error Type               | Message                              | Action                   |
| ------------------------ | ------------------------------------ | ------------------------ |
| Unknown version          | "Unknown file version: {version}"    | Attempt best-effort load |
| Missing rack             | "No rack found in layout"            | Show toast, abort load   |
| Invalid device reference | "Device '{id}' not found in library" | Skip device, warn user   |

### 7.4 Error Handling Code Pattern

```typescript
try {
	const layout = await loadLayout(file);
	layoutStore.load(layout);
	toastStore.showToast(`Loaded ${layout.name}`, 'success');
} catch (error) {
	console.error('Load failed:', error);

	if (error instanceof ValidationError) {
		toastStore.showToast(error.message, 'error');
	} else if (error instanceof MigrationError) {
		toastStore.showToast(
			`Migration failed: ${error.message}. Try loading in an older version.`,
			'error'
		);
	} else {
		toastStore.showToast('Failed to load file', 'error');
	}
}
```

---

## 8. Migration Strategy

### 8.1 Automatic Migration Flow

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  Load File  │────▶│ Detect Format│────▶│ Parse/Load  │
└─────────────┘     └──────────────┘     └─────────────┘
                           │
              ┌────────────┼────────────┐
              ▼            ▼            ▼
        ┌─────────┐  ┌─────────┐  ┌─────────┐
        │ v0.4    │  │ v0.3    │  │ v0.1-2  │
        │ (YAML)  │  │ (ZIP)   │  │ (JSON)  │
        └────┬────┘  └────┬────┘  └────┬────┘
             │            │            │
             │      ┌─────┴─────┐      │
             │      ▼           ▼      │
             │  ┌───────────────────┐  │
             │  │ Migration Layer   │  │
             │  │ migrateLayout()   │  │
             │  └─────────┬─────────┘  │
             │            │            │
             └────────────┼────────────┘
                          ▼
                   ┌─────────────┐
                   │ v0.4 Layout │
                   │  (Runtime)  │
                   └─────────────┘
```

### 8.2 Field Mapping

| v0.1-0.3                 | v0.4                          |
| ------------------------ | ----------------------------- |
| `Device.id`              | `DeviceType.slug` (generated) |
| `Device.name`            | Used for slug generation      |
| `Device.height`          | `DeviceType.u_height`         |
| `PlacedDevice.libraryId` | `Device.device_type`          |
| `deviceLibrary[]`        | `device_types[]`              |
| `racks[]`                | `rack` (first only)           |

### 8.3 Image Migration

When loading legacy archive:

1. Read images from `images/device-{uuid}-{face}.{ext}`
2. Map UUID to new slug via migration lookup
3. Store in memory under new slug key
4. On save, write to new `assets/{slug}/{face}.{ext}` structure

---

## 9. Testing Plan

### 9.1 Unit Tests

#### Slug Utilities (`utils/slug.test.ts`)

```typescript
describe('slugify', () => {
	it('converts name to lowercase slug', () => {
		expect(slugify('Synology DS920+')).toBe('synology-ds920-plus');
	});

	it('handles special characters', () => {
		expect(slugify('UniFi Dream Machine')).toBe('unifi-dream-machine');
	});

	it('collapses multiple hyphens', () => {
		expect(slugify('Some---Thing')).toBe('some-thing');
	});

	it('removes leading/trailing hyphens', () => {
		expect(slugify('-test-')).toBe('test');
	});
});

describe('ensureUniqueSlug', () => {
	it('returns original if unique', () => {
		const existing = new Set(['other-slug']);
		expect(ensureUniqueSlug('my-slug', existing)).toBe('my-slug');
	});

	it('appends number if duplicate', () => {
		const existing = new Set(['my-slug']);
		expect(ensureUniqueSlug('my-slug', existing)).toBe('my-slug-2');
	});

	it('increments number until unique', () => {
		const existing = new Set(['my-slug', 'my-slug-2', 'my-slug-3']);
		expect(ensureUniqueSlug('my-slug', existing)).toBe('my-slug-4');
	});
});
```

#### YAML Serialization (`utils/yaml.test.ts`)

```typescript
describe('serializeToYaml', () => {
	it('produces valid YAML', () => {
		const layout = createTestLayout();
		const yaml = serializeToYaml(layout);
		expect(() => parseYaml(yaml)).not.toThrow();
	});

	it('excludes runtime-only fields', () => {
		const layout = createTestLayout();
		layout.rack.view = 'rear';
		const yaml = serializeToYaml(layout);
		expect(yaml).not.toContain('view:');
	});
});

describe('parseYaml', () => {
	it('parses valid YAML', () => {
		const yamlString = `
version: "0.4.0"
name: Test
rack:
  name: Test
  height: 42
  width: 19
  desc_units: false
  form_factor: 4-post-cabinet
  starting_unit: 1
  position: 0
  devices: []
device_types: []
settings:
  display_mode: label
  show_labels_on_images: true
`;
		const layout = parseYaml(yamlString);
		expect(layout.name).toBe('Test');
	});

	it('throws on invalid YAML', () => {
		expect(() => parseYaml('invalid: [unclosed')).toThrow();
	});

	it('adds default view', () => {
		const layout = parseYaml(validYaml);
		expect(layout.rack.view).toBe('front');
	});
});
```

#### Migration (`utils/migration.test.ts`)

```typescript
describe('migrateLayout', () => {
	it('migrates v0.3 layout to v0.4', () => {
		const legacy = createLegacyLayout();
		const migrated = migrateLayout(legacy);

		expect(migrated.version).toBe('0.4.0');
		expect(migrated.device_types).toHaveLength(legacy.deviceLibrary.length);
	});

	it('generates unique slugs', () => {
		const legacy = createLegacyLayout();
		legacy.deviceLibrary.push(
			{ id: '1', name: 'Test Device', height: 1, category: 'server', colour: '#fff' },
			{ id: '2', name: 'Test Device', height: 2, category: 'server', colour: '#fff' }
		);

		const migrated = migrateLayout(legacy);
		const slugs = migrated.device_types.map((d) => d.slug);

		expect(slugs).toContain('test-device');
		expect(slugs).toContain('test-device-2');
	});

	it('maps libraryId to device_type slug', () => {
		const legacy = createLegacyLayout();
		const deviceId = legacy.deviceLibrary[0].id;
		legacy.racks[0].devices.push({ libraryId: deviceId, position: 10, face: 'front' });

		const migrated = migrateLayout(legacy);

		expect(migrated.rack.devices[0].device_type).toBe(migrated.device_types[0].slug);
	});
});
```

#### Zod Schemas (`schemas/device.test.ts`)

```typescript
describe('DeviceTypeSchema', () => {
	it('validates correct device type', () => {
		const deviceType = {
			slug: 'synology-ds920-plus',
			u_height: 2,
			rackarr: { colour: '#10b981', category: 'storage' }
		};

		expect(DeviceTypeSchema.safeParse(deviceType).success).toBe(true);
	});

	it('rejects invalid slug', () => {
		const deviceType = {
			slug: 'Invalid Slug!',
			u_height: 2,
			rackarr: { colour: '#10b981', category: 'storage' }
		};

		const result = DeviceTypeSchema.safeParse(deviceType);
		expect(result.success).toBe(false);
	});

	it('rejects invalid colour', () => {
		const deviceType = {
			slug: 'test',
			u_height: 2,
			rackarr: { colour: 'not-a-colour', category: 'storage' }
		};

		const result = DeviceTypeSchema.safeParse(deviceType);
		expect(result.success).toBe(false);
	});
});

describe('validateSlugUniqueness', () => {
	it('returns empty array for unique slugs', () => {
		const deviceTypes = [{ slug: 'a' }, { slug: 'b' }, { slug: 'c' }];
		expect(validateSlugUniqueness(deviceTypes)).toEqual([]);
	});

	it('returns duplicate slugs', () => {
		const deviceTypes = [{ slug: 'a' }, { slug: 'b' }, { slug: 'a' }];
		expect(validateSlugUniqueness(deviceTypes)).toEqual(['a']);
	});
});
```

### 9.2 Integration Tests

#### File Save/Load Cycle

```typescript
describe('File operations', () => {
	it('saves and loads layout with images', async () => {
		const originalLayout = createTestLayoutWithDevices();
		const images = createTestImages();

		// Save
		const blob = await saveAsFolder(originalLayout, images);

		// Load
		const { layout, images: loadedImages } = await loadFromFolder(blob);

		// Verify
		expect(layout.name).toBe(originalLayout.name);
		expect(layout.device_types).toHaveLength(originalLayout.device_types.length);
		expect(loadedImages.size).toBe(images.size);
	});

	it('loads legacy v0.3 archive', async () => {
		const legacyBlob = await createLegacyArchive();

		const { layout } = await loadLayout(legacyBlob);

		expect(layout.version).toBe('0.4.0');
		expect(layout.device_types).toBeDefined();
	});
});
```

### 9.3 E2E Tests

#### Save/Load Flow (`e2e/file-operations.spec.ts`)

```typescript
test('create rack, add device, save, reload', async ({ page }) => {
	// Create new rack
	await page.click('[data-testid="new-rack-button"]');
	await page.fill('[data-testid="rack-name-input"]', 'Test Rack');
	await page.click('[data-testid="create-rack-button"]');

	// Add device to library
	await page.click('[data-testid="add-device-button"]');
	await page.fill('[data-testid="device-name-input"]', 'Test Server');
	await page.click('[data-testid="add-device-submit"]');

	// Place device
	await page.dragAndDrop('[data-testid="device-palette-item"]', '[data-testid="rack-unit-10"]');

	// Save
	const downloadPromise = page.waitForEvent('download');
	await page.keyboard.press('Control+s');
	const download = await downloadPromise;
	expect(download.suggestedFilename()).toBe('test-rack.zip');

	// Reload page
	await page.reload();

	// Load saved file
	const fileChooserPromise = page.waitForEvent('filechooser');
	await page.keyboard.press('Control+o');
	const fileChooser = await fileChooserPromise;
	await fileChooser.setFiles(await download.path());

	// Verify
	await expect(page.locator('[data-testid="rack-name"]')).toHaveText('Test Rack');
	await expect(page.locator('[data-testid="placed-device"]')).toHaveCount(1);
});

test('loads legacy .rackarr.zip file', async ({ page }) => {
	// Load legacy file from fixtures
	const fileChooserPromise = page.waitForEvent('filechooser');
	await page.keyboard.press('Control+o');
	const fileChooser = await fileChooserPromise;
	await fileChooser.setFiles('e2e/fixtures/legacy-v0.3.rackarr.zip');

	// Verify migration worked
	await expect(page.locator('[data-testid="rack"]')).toBeVisible();
	await expect(page.locator('[data-testid="placed-device"]')).toHaveCount(3);
});
```

### 9.4 Test Fixtures

Create test fixtures directory:

```
e2e/fixtures/
├── legacy-v0.1.rackarr.json
├── legacy-v0.3.rackarr.zip
└── valid-v0.4/
    ├── valid-v0.4.yaml
    └── assets/
        └── test-device/
            └── front.png
```

---

## 10. Acceptance Criteria

### 10.1 Must Have

- [ ] All TypeScript interfaces use snake_case naming
- [ ] `Device` renamed to `DeviceType`, `PlacedDevice` renamed to `Device`
- [ ] `height` field renamed to `u_height`
- [ ] `libraryId` field renamed to `device_type` (contains slug)
- [ ] DeviceType uses `slug` for identification (auto-generated from name)
- [ ] Placed devices can have optional `name` for display override
- [ ] Projects save as folder structure (`[name]/[name].yaml` + `assets/`)
- [ ] Images stored in `assets/[slug]/[face].[ext]`
- [ ] Legacy `.rackarr.zip` files load correctly with automatic migration
- [ ] Legacy `.rackarr.json` files load correctly with automatic migration
- [ ] All existing unit tests pass (or are updated)
- [ ] All existing E2E tests pass (or are updated)
- [ ] Zod schemas validate new structure
- [ ] Slug uniqueness validated on save

### 10.2 Should Have

- [ ] Meaningful error messages for validation failures
- [ ] Toast notification shows filename on save
- [ ] YAML output is human-readable (proper indentation)
- [ ] "Export as ZIP" option for sharing

### 10.3 Nice to Have

- [ ] YAML comments in output (version header, section separators)
- [ ] Slug suggestions when duplicate detected
- [ ] Preview of generated slug while typing name

---

## Appendix A: Glossary

| Term              | Definition                                                     |
| ----------------- | -------------------------------------------------------------- |
| **DeviceType**    | A template definition for equipment (e.g., "Synology DS920+")  |
| **Device**        | A placed instance of a DeviceType in a rack                    |
| **Slug**          | Human-readable unique identifier (e.g., "synology-ds920-plus") |
| **U / Rack Unit** | Standard unit of rack height (1U = 1.75 inches)                |
| **Face**          | Which side of the rack a device is mounted (front, rear, both) |

## Appendix B: Reference Links

- [NetBox Device Type Library](https://github.com/netbox-community/devicetype-library)
- [js-yaml Documentation](https://github.com/nodeca/js-yaml)
- [Zod Documentation](https://zod.dev/)
